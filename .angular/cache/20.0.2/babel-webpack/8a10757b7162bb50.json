{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, inject, ElementRef, ErrorHandler, HostAttributeToken, booleanAttribute, Component, ViewEncapsulation, ChangeDetectionStrategy, Input, NgModule } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\nimport { Subscription } from 'rxjs';\nimport { take } from 'rxjs/operators';\nimport { M as MatIconRegistry } from './icon-registry-B2IMBfNA.mjs';\nconst _c0 = [\"*\"];\nexport { d as ICON_REGISTRY_PROVIDER, I as ICON_REGISTRY_PROVIDER_FACTORY, c as getMatIconFailedToSanitizeLiteralError, b as getMatIconFailedToSanitizeUrlError, g as getMatIconNameNotFoundError, a as getMatIconNoHttpProviderError } from './icon-registry-B2IMBfNA.mjs';\nimport { M as MatCommonModule } from './common-module-WayjW0Pb.mjs';\nimport '@angular/common/http';\nimport '@angular/platform-browser';\nimport '@angular/cdk/a11y';\nimport '@angular/cdk/bidi';\n\n/** Injection token to be used to override the default options for `mat-icon`. */\nconst MAT_ICON_DEFAULT_OPTIONS = /*#__PURE__*/new InjectionToken('MAT_ICON_DEFAULT_OPTIONS');\n/**\n * Injection token used to provide the current location to `MatIcon`.\n * Used to handle server-side rendering and to stub out during unit tests.\n * @docs-private\n */\nconst MAT_ICON_LOCATION = /*#__PURE__*/new InjectionToken('mat-icon-location', {\n  providedIn: 'root',\n  factory: MAT_ICON_LOCATION_FACTORY\n});\n/**\n * @docs-private\n * @deprecated No longer used, will be removed.\n * @breaking-change 21.0.0\n */\nfunction MAT_ICON_LOCATION_FACTORY() {\n  const _document = inject(DOCUMENT);\n  const _location = _document ? _document.location : null;\n  return {\n    // Note that this needs to be a function, rather than a property, because Angular\n    // will only resolve it once, but we want the current path on each call.\n    getPathname: () => _location ? _location.pathname + _location.search : ''\n  };\n}\n/** SVG attributes that accept a FuncIRI (e.g. `url(<something>)`). */\nconst funcIriAttributes = ['clip-path', 'color-profile', 'src', 'cursor', 'fill', 'filter', 'marker', 'marker-start', 'marker-mid', 'marker-end', 'mask', 'stroke'];\n/** Selector that can be used to find all elements that are using a `FuncIRI`. */\nconst funcIriAttributeSelector = /*#__PURE__*/ /*#__PURE__*/funcIriAttributes.map(attr => `[${attr}]`).join(', ');\n/** Regex that can be used to extract the id out of a FuncIRI. */\nconst funcIriPattern = /^url\\(['\"]?#(.*?)['\"]?\\)$/;\n/**\n * Component to display an icon. It can be used in the following ways:\n *\n * - Specify the svgIcon input to load an SVG icon from a URL previously registered with the\n *   addSvgIcon, addSvgIconInNamespace, addSvgIconSet, or addSvgIconSetInNamespace methods of\n *   MatIconRegistry. If the svgIcon value contains a colon it is assumed to be in the format\n *   \"[namespace]:[name]\", if not the value will be the name of an icon in the default namespace.\n *   Examples:\n *     `<mat-icon svgIcon=\"left-arrow\"></mat-icon>\n *     <mat-icon svgIcon=\"animals:cat\"></mat-icon>`\n *\n * - Use a font ligature as an icon by putting the ligature text in the `fontIcon` attribute or the\n *   content of the `<mat-icon>` component. If you register a custom font class, don't forget to also\n *   include the special class `mat-ligature-font`. It is recommended to use the attribute alternative\n *   to prevent the ligature text to be selectable and to appear in search engine results.\n *   By default, the Material icons font is used as described at\n *   http://google.github.io/material-design-icons/#icon-font-for-the-web. You can specify an\n *   alternate font by setting the fontSet input to either the CSS class to apply to use the\n *   desired font, or to an alias previously registered with MatIconRegistry.registerFontClassAlias.\n *   Examples:\n *     `<mat-icon fontIcon=\"home\"></mat-icon>\n *     <mat-icon>home</mat-icon>\n *     <mat-icon fontSet=\"myfont\" fontIcon=\"sun\"></mat-icon>\n *     <mat-icon fontSet=\"myfont\">sun</mat-icon>`\n *\n * - Specify a font glyph to be included via CSS rules by setting the fontSet input to specify the\n *   font, and the fontIcon input to specify the icon. Typically the fontIcon will specify a\n *   CSS class which causes the glyph to be displayed via a :before selector, as in\n *   https://fontawesome-v4.github.io/examples/\n *   Example:\n *     `<mat-icon fontSet=\"fa\" fontIcon=\"alarm\"></mat-icon>`\n */\nlet MatIcon = /*#__PURE__*/(() => {\n  class MatIcon {\n    _elementRef = inject(ElementRef);\n    _iconRegistry = inject(MatIconRegistry);\n    _location = inject(MAT_ICON_LOCATION);\n    _errorHandler = inject(ErrorHandler);\n    _defaultColor;\n    /**\n     * Theme color of the icon. This API is supported in M2 themes only, it\n     * has no effect in M3 themes. For color customization in M3, see https://material.angular.dev/components/icon/styling.\n     *\n     * For information on applying color variants in M3, see\n     * https://material.angular.dev/guide/material-2-theming#optional-add-backwards-compatibility-styles-for-color-variants\n     */\n    get color() {\n      return this._color || this._defaultColor;\n    }\n    set color(value) {\n      this._color = value;\n    }\n    _color;\n    /**\n     * Whether the icon should be inlined, automatically sizing the icon to match the font size of\n     * the element the icon is contained in.\n     */\n    inline = false;\n    /** Name of the icon in the SVG icon set. */\n    get svgIcon() {\n      return this._svgIcon;\n    }\n    set svgIcon(value) {\n      if (value !== this._svgIcon) {\n        if (value) {\n          this._updateSvgIcon(value);\n        } else if (this._svgIcon) {\n          this._clearSvgElement();\n        }\n        this._svgIcon = value;\n      }\n    }\n    _svgIcon;\n    /** Font set that the icon is a part of. */\n    get fontSet() {\n      return this._fontSet;\n    }\n    set fontSet(value) {\n      const newValue = this._cleanupFontValue(value);\n      if (newValue !== this._fontSet) {\n        this._fontSet = newValue;\n        this._updateFontIconClasses();\n      }\n    }\n    _fontSet;\n    /** Name of an icon within a font set. */\n    get fontIcon() {\n      return this._fontIcon;\n    }\n    set fontIcon(value) {\n      const newValue = this._cleanupFontValue(value);\n      if (newValue !== this._fontIcon) {\n        this._fontIcon = newValue;\n        this._updateFontIconClasses();\n      }\n    }\n    _fontIcon;\n    _previousFontSetClass = [];\n    _previousFontIconClass;\n    _svgName;\n    _svgNamespace;\n    /** Keeps track of the current page path. */\n    _previousPath;\n    /** Keeps track of the elements and attributes that we've prefixed with the current path. */\n    _elementsWithExternalReferences;\n    /** Subscription to the current in-progress SVG icon request. */\n    _currentIconFetch = Subscription.EMPTY;\n    constructor() {\n      const ariaHidden = inject(new HostAttributeToken('aria-hidden'), {\n        optional: true\n      });\n      const defaults = inject(MAT_ICON_DEFAULT_OPTIONS, {\n        optional: true\n      });\n      if (defaults) {\n        if (defaults.color) {\n          this.color = this._defaultColor = defaults.color;\n        }\n        if (defaults.fontSet) {\n          this.fontSet = defaults.fontSet;\n        }\n      }\n      // If the user has not explicitly set aria-hidden, mark the icon as hidden, as this is\n      // the right thing to do for the majority of icon use-cases.\n      if (!ariaHidden) {\n        this._elementRef.nativeElement.setAttribute('aria-hidden', 'true');\n      }\n    }\n    /**\n     * Splits an svgIcon binding value into its icon set and icon name components.\n     * Returns a 2-element array of [(icon set), (icon name)].\n     * The separator for the two fields is ':'. If there is no separator, an empty\n     * string is returned for the icon set and the entire value is returned for\n     * the icon name. If the argument is falsy, returns an array of two empty strings.\n     * Throws an error if the name contains two or more ':' separators.\n     * Examples:\n     *   `'social:cake' -> ['social', 'cake']\n     *   'penguin' -> ['', 'penguin']\n     *   null -> ['', '']\n     *   'a:b:c' -> (throws Error)`\n     */\n    _splitIconName(iconName) {\n      if (!iconName) {\n        return ['', ''];\n      }\n      const parts = iconName.split(':');\n      switch (parts.length) {\n        case 1:\n          return ['', parts[0]];\n        // Use default namespace.\n        case 2:\n          return parts;\n        default:\n          throw Error(`Invalid icon name: \"${iconName}\"`);\n        // TODO: add an ngDevMode check\n      }\n    }\n    ngOnInit() {\n      // Update font classes because ngOnChanges won't be called if none of the inputs are present,\n      // e.g. <mat-icon>arrow</mat-icon> In this case we need to add a CSS class for the default font.\n      this._updateFontIconClasses();\n    }\n    ngAfterViewChecked() {\n      const cachedElements = this._elementsWithExternalReferences;\n      if (cachedElements && cachedElements.size) {\n        const newPath = this._location.getPathname();\n        // We need to check whether the URL has changed on each change detection since\n        // the browser doesn't have an API that will let us react on link clicks and\n        // we can't depend on the Angular router. The references need to be updated,\n        // because while most browsers don't care whether the URL is correct after\n        // the first render, Safari will break if the user navigates to a different\n        // page and the SVG isn't re-rendered.\n        if (newPath !== this._previousPath) {\n          this._previousPath = newPath;\n          this._prependPathToReferences(newPath);\n        }\n      }\n    }\n    ngOnDestroy() {\n      this._currentIconFetch.unsubscribe();\n      if (this._elementsWithExternalReferences) {\n        this._elementsWithExternalReferences.clear();\n      }\n    }\n    _usingFontIcon() {\n      return !this.svgIcon;\n    }\n    _setSvgElement(svg) {\n      this._clearSvgElement();\n      // Note: we do this fix here, rather than the icon registry, because the\n      // references have to point to the URL at the time that the icon was created.\n      const path = this._location.getPathname();\n      this._previousPath = path;\n      this._cacheChildrenWithExternalReferences(svg);\n      this._prependPathToReferences(path);\n      this._elementRef.nativeElement.appendChild(svg);\n    }\n    _clearSvgElement() {\n      const layoutElement = this._elementRef.nativeElement;\n      let childCount = layoutElement.childNodes.length;\n      if (this._elementsWithExternalReferences) {\n        this._elementsWithExternalReferences.clear();\n      }\n      // Remove existing non-element child nodes and SVGs, and add the new SVG element. Note that\n      // we can't use innerHTML, because IE will throw if the element has a data binding.\n      while (childCount--) {\n        const child = layoutElement.childNodes[childCount];\n        // 1 corresponds to Node.ELEMENT_NODE. We remove all non-element nodes in order to get rid\n        // of any loose text nodes, as well as any SVG elements in order to remove any old icons.\n        if (child.nodeType !== 1 || child.nodeName.toLowerCase() === 'svg') {\n          child.remove();\n        }\n      }\n    }\n    _updateFontIconClasses() {\n      if (!this._usingFontIcon()) {\n        return;\n      }\n      const elem = this._elementRef.nativeElement;\n      const fontSetClasses = (this.fontSet ? this._iconRegistry.classNameForFontAlias(this.fontSet).split(/ +/) : this._iconRegistry.getDefaultFontSetClass()).filter(className => className.length > 0);\n      this._previousFontSetClass.forEach(className => elem.classList.remove(className));\n      fontSetClasses.forEach(className => elem.classList.add(className));\n      this._previousFontSetClass = fontSetClasses;\n      if (this.fontIcon !== this._previousFontIconClass && !fontSetClasses.includes('mat-ligature-font')) {\n        if (this._previousFontIconClass) {\n          elem.classList.remove(this._previousFontIconClass);\n        }\n        if (this.fontIcon) {\n          elem.classList.add(this.fontIcon);\n        }\n        this._previousFontIconClass = this.fontIcon;\n      }\n    }\n    /**\n     * Cleans up a value to be used as a fontIcon or fontSet.\n     * Since the value ends up being assigned as a CSS class, we\n     * have to trim the value and omit space-separated values.\n     */\n    _cleanupFontValue(value) {\n      return typeof value === 'string' ? value.trim().split(' ')[0] : value;\n    }\n    /**\n     * Prepends the current path to all elements that have an attribute pointing to a `FuncIRI`\n     * reference. This is required because WebKit browsers require references to be prefixed with\n     * the current path, if the page has a `base` tag.\n     */\n    _prependPathToReferences(path) {\n      const elements = this._elementsWithExternalReferences;\n      if (elements) {\n        elements.forEach((attrs, element) => {\n          attrs.forEach(attr => {\n            element.setAttribute(attr.name, `url('${path}#${attr.value}')`);\n          });\n        });\n      }\n    }\n    /**\n     * Caches the children of an SVG element that have `url()`\n     * references that we need to prefix with the current path.\n     */\n    _cacheChildrenWithExternalReferences(element) {\n      const elementsWithFuncIri = element.querySelectorAll(funcIriAttributeSelector);\n      const elements = this._elementsWithExternalReferences = this._elementsWithExternalReferences || new Map();\n      for (let i = 0; i < elementsWithFuncIri.length; i++) {\n        funcIriAttributes.forEach(attr => {\n          const elementWithReference = elementsWithFuncIri[i];\n          const value = elementWithReference.getAttribute(attr);\n          const match = value ? value.match(funcIriPattern) : null;\n          if (match) {\n            let attributes = elements.get(elementWithReference);\n            if (!attributes) {\n              attributes = [];\n              elements.set(elementWithReference, attributes);\n            }\n            attributes.push({\n              name: attr,\n              value: match[1]\n            });\n          }\n        });\n      }\n    }\n    /** Sets a new SVG icon with a particular name. */\n    _updateSvgIcon(rawName) {\n      this._svgNamespace = null;\n      this._svgName = null;\n      this._currentIconFetch.unsubscribe();\n      if (rawName) {\n        const [namespace, iconName] = this._splitIconName(rawName);\n        if (namespace) {\n          this._svgNamespace = namespace;\n        }\n        if (iconName) {\n          this._svgName = iconName;\n        }\n        this._currentIconFetch = this._iconRegistry.getNamedSvgIcon(iconName, namespace).pipe(take(1)).subscribe(svg => this._setSvgElement(svg), err => {\n          const errorMessage = `Error retrieving icon ${namespace}:${iconName}! ${err.message}`;\n          this._errorHandler.handleError(new Error(errorMessage));\n        });\n      }\n    }\n    static ɵfac = function MatIcon_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatIcon)();\n    };\n    static ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: MatIcon,\n      selectors: [[\"mat-icon\"]],\n      hostAttrs: [\"role\", \"img\", 1, \"mat-icon\", \"notranslate\"],\n      hostVars: 10,\n      hostBindings: function MatIcon_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵattribute(\"data-mat-icon-type\", ctx._usingFontIcon() ? \"font\" : \"svg\")(\"data-mat-icon-name\", ctx._svgName || ctx.fontIcon)(\"data-mat-icon-namespace\", ctx._svgNamespace || ctx.fontSet)(\"fontIcon\", ctx._usingFontIcon() ? ctx.fontIcon : null);\n          i0.ɵɵclassMap(ctx.color ? \"mat-\" + ctx.color : \"\");\n          i0.ɵɵclassProp(\"mat-icon-inline\", ctx.inline)(\"mat-icon-no-color\", ctx.color !== \"primary\" && ctx.color !== \"accent\" && ctx.color !== \"warn\");\n        }\n      },\n      inputs: {\n        color: \"color\",\n        inline: [2, \"inline\", \"inline\", booleanAttribute],\n        svgIcon: \"svgIcon\",\n        fontSet: \"fontSet\",\n        fontIcon: \"fontIcon\"\n      },\n      exportAs: [\"matIcon\"],\n      ngContentSelectors: _c0,\n      decls: 1,\n      vars: 0,\n      template: function MatIcon_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      styles: [\"mat-icon,mat-icon.mat-primary,mat-icon.mat-accent,mat-icon.mat-warn{color:var(--mat-icon-color, inherit)}.mat-icon{-webkit-user-select:none;user-select:none;background-repeat:no-repeat;display:inline-block;fill:currentColor;height:24px;width:24px;overflow:hidden}.mat-icon.mat-icon-inline{font-size:inherit;height:inherit;line-height:inherit;width:inherit}.mat-icon.mat-ligature-font[fontIcon]::before{content:attr(fontIcon)}[dir=rtl] .mat-icon-rtl-mirror{transform:scale(-1, 1)}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon{display:block}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-icon{margin:auto}\\n\"],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return MatIcon;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MatIconModule = /*#__PURE__*/(() => {\n  class MatIconModule {\n    static ɵfac = function MatIconModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MatIconModule)();\n    };\n    static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: MatIconModule\n    });\n    static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      imports: [MatCommonModule, MatCommonModule]\n    });\n  }\n  return MatIconModule;\n})();\n/*#__PURE__*/(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nexport { MAT_ICON_DEFAULT_OPTIONS, MAT_ICON_LOCATION, MAT_ICON_LOCATION_FACTORY, MatIcon, MatIconModule, MatIconRegistry };","map":{"version":3,"names":["i0","InjectionToken","inject","ElementRef","ErrorHandler","HostAttributeToken","booleanAttribute","Component","ViewEncapsulation","ChangeDetectionStrategy","Input","NgModule","DOCUMENT","Subscription","take","M","MatIconRegistry","_c0","d","ICON_REGISTRY_PROVIDER","I","ICON_REGISTRY_PROVIDER_FACTORY","c","getMatIconFailedToSanitizeLiteralError","b","getMatIconFailedToSanitizeUrlError","g","getMatIconNameNotFoundError","a","getMatIconNoHttpProviderError","MatCommonModule","MAT_ICON_DEFAULT_OPTIONS","MAT_ICON_LOCATION","providedIn","factory","MAT_ICON_LOCATION_FACTORY","_document","_location","location","getPathname","pathname","search","funcIriAttributes","funcIriAttributeSelector","map","attr","join","funcIriPattern","MatIcon","_elementRef","_iconRegistry","_errorHandler","_defaultColor","color","_color","value","inline","svgIcon","_svgIcon","_updateSvgIcon","_clearSvgElement","fontSet","_fontSet","newValue","_cleanupFontValue","_updateFontIconClasses","fontIcon","_fontIcon","_previousFontSetClass","_previousFontIconClass","_svgName","_svgNamespace","_previousPath","_elementsWithExternalReferences","_currentIconFetch","EMPTY","constructor","ariaHidden","optional","defaults","nativeElement","setAttribute","_splitIconName","iconName","parts","split","length","Error","ngOnInit","ngAfterViewChecked","cachedElements","size","newPath","_prependPathToReferences","ngOnDestroy","unsubscribe","clear","_usingFontIcon","_setSvgElement","svg","path","_cacheChildrenWithExternalReferences","appendChild","layoutElement","childCount","childNodes","child","nodeType","nodeName","toLowerCase","remove","elem","fontSetClasses","classNameForFontAlias","getDefaultFontSetClass","filter","className","forEach","classList","add","includes","trim","elements","attrs","element","name","elementsWithFuncIri","querySelectorAll","Map","i","elementWithReference","getAttribute","match","attributes","get","set","push","rawName","namespace","getNamedSvgIcon","pipe","subscribe","err","errorMessage","message","handleError","ɵfac","MatIcon_Factory","__ngFactoryType__","ɵcmp","ɵɵdefineComponent","type","selectors","hostAttrs","hostVars","hostBindings","MatIcon_HostBindings","rf","ctx","ɵɵattribute","ɵɵclassMap","ɵɵclassProp","inputs","exportAs","ngContentSelectors","decls","vars","template","MatIcon_Template","ɵɵprojectionDef","ɵɵprojection","styles","encapsulation","changeDetection","ngDevMode","MatIconModule","MatIconModule_Factory","ɵmod","ɵɵdefineNgModule","ɵinj","ɵɵdefineInjector","imports"],"sources":["C:/Users/ASUS/Documents/UNIVERSIDAD/SEXTO SEMESTRE/PROCESOS ADMINISTRATIVOS/IngenieriaProg/node_modules/@angular/material/fesm2022/icon.mjs"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { InjectionToken, inject, ElementRef, ErrorHandler, HostAttributeToken, booleanAttribute, Component, ViewEncapsulation, ChangeDetectionStrategy, Input, NgModule } from '@angular/core';\nimport { DOCUMENT } from '@angular/common';\nimport { Subscription } from 'rxjs';\nimport { take } from 'rxjs/operators';\nimport { M as MatIconRegistry } from './icon-registry-B2IMBfNA.mjs';\nexport { d as ICON_REGISTRY_PROVIDER, I as ICON_REGISTRY_PROVIDER_FACTORY, c as getMatIconFailedToSanitizeLiteralError, b as getMatIconFailedToSanitizeUrlError, g as getMatIconNameNotFoundError, a as getMatIconNoHttpProviderError } from './icon-registry-B2IMBfNA.mjs';\nimport { M as MatCommonModule } from './common-module-WayjW0Pb.mjs';\nimport '@angular/common/http';\nimport '@angular/platform-browser';\nimport '@angular/cdk/a11y';\nimport '@angular/cdk/bidi';\n\n/** Injection token to be used to override the default options for `mat-icon`. */\nconst MAT_ICON_DEFAULT_OPTIONS = new InjectionToken('MAT_ICON_DEFAULT_OPTIONS');\n/**\n * Injection token used to provide the current location to `MatIcon`.\n * Used to handle server-side rendering and to stub out during unit tests.\n * @docs-private\n */\nconst MAT_ICON_LOCATION = new InjectionToken('mat-icon-location', {\n    providedIn: 'root',\n    factory: MAT_ICON_LOCATION_FACTORY,\n});\n/**\n * @docs-private\n * @deprecated No longer used, will be removed.\n * @breaking-change 21.0.0\n */\nfunction MAT_ICON_LOCATION_FACTORY() {\n    const _document = inject(DOCUMENT);\n    const _location = _document ? _document.location : null;\n    return {\n        // Note that this needs to be a function, rather than a property, because Angular\n        // will only resolve it once, but we want the current path on each call.\n        getPathname: () => (_location ? _location.pathname + _location.search : ''),\n    };\n}\n/** SVG attributes that accept a FuncIRI (e.g. `url(<something>)`). */\nconst funcIriAttributes = [\n    'clip-path',\n    'color-profile',\n    'src',\n    'cursor',\n    'fill',\n    'filter',\n    'marker',\n    'marker-start',\n    'marker-mid',\n    'marker-end',\n    'mask',\n    'stroke',\n];\n/** Selector that can be used to find all elements that are using a `FuncIRI`. */\nconst funcIriAttributeSelector = funcIriAttributes.map(attr => `[${attr}]`).join(', ');\n/** Regex that can be used to extract the id out of a FuncIRI. */\nconst funcIriPattern = /^url\\(['\"]?#(.*?)['\"]?\\)$/;\n/**\n * Component to display an icon. It can be used in the following ways:\n *\n * - Specify the svgIcon input to load an SVG icon from a URL previously registered with the\n *   addSvgIcon, addSvgIconInNamespace, addSvgIconSet, or addSvgIconSetInNamespace methods of\n *   MatIconRegistry. If the svgIcon value contains a colon it is assumed to be in the format\n *   \"[namespace]:[name]\", if not the value will be the name of an icon in the default namespace.\n *   Examples:\n *     `<mat-icon svgIcon=\"left-arrow\"></mat-icon>\n *     <mat-icon svgIcon=\"animals:cat\"></mat-icon>`\n *\n * - Use a font ligature as an icon by putting the ligature text in the `fontIcon` attribute or the\n *   content of the `<mat-icon>` component. If you register a custom font class, don't forget to also\n *   include the special class `mat-ligature-font`. It is recommended to use the attribute alternative\n *   to prevent the ligature text to be selectable and to appear in search engine results.\n *   By default, the Material icons font is used as described at\n *   http://google.github.io/material-design-icons/#icon-font-for-the-web. You can specify an\n *   alternate font by setting the fontSet input to either the CSS class to apply to use the\n *   desired font, or to an alias previously registered with MatIconRegistry.registerFontClassAlias.\n *   Examples:\n *     `<mat-icon fontIcon=\"home\"></mat-icon>\n *     <mat-icon>home</mat-icon>\n *     <mat-icon fontSet=\"myfont\" fontIcon=\"sun\"></mat-icon>\n *     <mat-icon fontSet=\"myfont\">sun</mat-icon>`\n *\n * - Specify a font glyph to be included via CSS rules by setting the fontSet input to specify the\n *   font, and the fontIcon input to specify the icon. Typically the fontIcon will specify a\n *   CSS class which causes the glyph to be displayed via a :before selector, as in\n *   https://fontawesome-v4.github.io/examples/\n *   Example:\n *     `<mat-icon fontSet=\"fa\" fontIcon=\"alarm\"></mat-icon>`\n */\nclass MatIcon {\n    _elementRef = inject(ElementRef);\n    _iconRegistry = inject(MatIconRegistry);\n    _location = inject(MAT_ICON_LOCATION);\n    _errorHandler = inject(ErrorHandler);\n    _defaultColor;\n    /**\n     * Theme color of the icon. This API is supported in M2 themes only, it\n     * has no effect in M3 themes. For color customization in M3, see https://material.angular.dev/components/icon/styling.\n     *\n     * For information on applying color variants in M3, see\n     * https://material.angular.dev/guide/material-2-theming#optional-add-backwards-compatibility-styles-for-color-variants\n     */\n    get color() {\n        return this._color || this._defaultColor;\n    }\n    set color(value) {\n        this._color = value;\n    }\n    _color;\n    /**\n     * Whether the icon should be inlined, automatically sizing the icon to match the font size of\n     * the element the icon is contained in.\n     */\n    inline = false;\n    /** Name of the icon in the SVG icon set. */\n    get svgIcon() {\n        return this._svgIcon;\n    }\n    set svgIcon(value) {\n        if (value !== this._svgIcon) {\n            if (value) {\n                this._updateSvgIcon(value);\n            }\n            else if (this._svgIcon) {\n                this._clearSvgElement();\n            }\n            this._svgIcon = value;\n        }\n    }\n    _svgIcon;\n    /** Font set that the icon is a part of. */\n    get fontSet() {\n        return this._fontSet;\n    }\n    set fontSet(value) {\n        const newValue = this._cleanupFontValue(value);\n        if (newValue !== this._fontSet) {\n            this._fontSet = newValue;\n            this._updateFontIconClasses();\n        }\n    }\n    _fontSet;\n    /** Name of an icon within a font set. */\n    get fontIcon() {\n        return this._fontIcon;\n    }\n    set fontIcon(value) {\n        const newValue = this._cleanupFontValue(value);\n        if (newValue !== this._fontIcon) {\n            this._fontIcon = newValue;\n            this._updateFontIconClasses();\n        }\n    }\n    _fontIcon;\n    _previousFontSetClass = [];\n    _previousFontIconClass;\n    _svgName;\n    _svgNamespace;\n    /** Keeps track of the current page path. */\n    _previousPath;\n    /** Keeps track of the elements and attributes that we've prefixed with the current path. */\n    _elementsWithExternalReferences;\n    /** Subscription to the current in-progress SVG icon request. */\n    _currentIconFetch = Subscription.EMPTY;\n    constructor() {\n        const ariaHidden = inject(new HostAttributeToken('aria-hidden'), { optional: true });\n        const defaults = inject(MAT_ICON_DEFAULT_OPTIONS, { optional: true });\n        if (defaults) {\n            if (defaults.color) {\n                this.color = this._defaultColor = defaults.color;\n            }\n            if (defaults.fontSet) {\n                this.fontSet = defaults.fontSet;\n            }\n        }\n        // If the user has not explicitly set aria-hidden, mark the icon as hidden, as this is\n        // the right thing to do for the majority of icon use-cases.\n        if (!ariaHidden) {\n            this._elementRef.nativeElement.setAttribute('aria-hidden', 'true');\n        }\n    }\n    /**\n     * Splits an svgIcon binding value into its icon set and icon name components.\n     * Returns a 2-element array of [(icon set), (icon name)].\n     * The separator for the two fields is ':'. If there is no separator, an empty\n     * string is returned for the icon set and the entire value is returned for\n     * the icon name. If the argument is falsy, returns an array of two empty strings.\n     * Throws an error if the name contains two or more ':' separators.\n     * Examples:\n     *   `'social:cake' -> ['social', 'cake']\n     *   'penguin' -> ['', 'penguin']\n     *   null -> ['', '']\n     *   'a:b:c' -> (throws Error)`\n     */\n    _splitIconName(iconName) {\n        if (!iconName) {\n            return ['', ''];\n        }\n        const parts = iconName.split(':');\n        switch (parts.length) {\n            case 1:\n                return ['', parts[0]]; // Use default namespace.\n            case 2:\n                return parts;\n            default:\n                throw Error(`Invalid icon name: \"${iconName}\"`); // TODO: add an ngDevMode check\n        }\n    }\n    ngOnInit() {\n        // Update font classes because ngOnChanges won't be called if none of the inputs are present,\n        // e.g. <mat-icon>arrow</mat-icon> In this case we need to add a CSS class for the default font.\n        this._updateFontIconClasses();\n    }\n    ngAfterViewChecked() {\n        const cachedElements = this._elementsWithExternalReferences;\n        if (cachedElements && cachedElements.size) {\n            const newPath = this._location.getPathname();\n            // We need to check whether the URL has changed on each change detection since\n            // the browser doesn't have an API that will let us react on link clicks and\n            // we can't depend on the Angular router. The references need to be updated,\n            // because while most browsers don't care whether the URL is correct after\n            // the first render, Safari will break if the user navigates to a different\n            // page and the SVG isn't re-rendered.\n            if (newPath !== this._previousPath) {\n                this._previousPath = newPath;\n                this._prependPathToReferences(newPath);\n            }\n        }\n    }\n    ngOnDestroy() {\n        this._currentIconFetch.unsubscribe();\n        if (this._elementsWithExternalReferences) {\n            this._elementsWithExternalReferences.clear();\n        }\n    }\n    _usingFontIcon() {\n        return !this.svgIcon;\n    }\n    _setSvgElement(svg) {\n        this._clearSvgElement();\n        // Note: we do this fix here, rather than the icon registry, because the\n        // references have to point to the URL at the time that the icon was created.\n        const path = this._location.getPathname();\n        this._previousPath = path;\n        this._cacheChildrenWithExternalReferences(svg);\n        this._prependPathToReferences(path);\n        this._elementRef.nativeElement.appendChild(svg);\n    }\n    _clearSvgElement() {\n        const layoutElement = this._elementRef.nativeElement;\n        let childCount = layoutElement.childNodes.length;\n        if (this._elementsWithExternalReferences) {\n            this._elementsWithExternalReferences.clear();\n        }\n        // Remove existing non-element child nodes and SVGs, and add the new SVG element. Note that\n        // we can't use innerHTML, because IE will throw if the element has a data binding.\n        while (childCount--) {\n            const child = layoutElement.childNodes[childCount];\n            // 1 corresponds to Node.ELEMENT_NODE. We remove all non-element nodes in order to get rid\n            // of any loose text nodes, as well as any SVG elements in order to remove any old icons.\n            if (child.nodeType !== 1 || child.nodeName.toLowerCase() === 'svg') {\n                child.remove();\n            }\n        }\n    }\n    _updateFontIconClasses() {\n        if (!this._usingFontIcon()) {\n            return;\n        }\n        const elem = this._elementRef.nativeElement;\n        const fontSetClasses = (this.fontSet\n            ? this._iconRegistry.classNameForFontAlias(this.fontSet).split(/ +/)\n            : this._iconRegistry.getDefaultFontSetClass()).filter(className => className.length > 0);\n        this._previousFontSetClass.forEach(className => elem.classList.remove(className));\n        fontSetClasses.forEach(className => elem.classList.add(className));\n        this._previousFontSetClass = fontSetClasses;\n        if (this.fontIcon !== this._previousFontIconClass &&\n            !fontSetClasses.includes('mat-ligature-font')) {\n            if (this._previousFontIconClass) {\n                elem.classList.remove(this._previousFontIconClass);\n            }\n            if (this.fontIcon) {\n                elem.classList.add(this.fontIcon);\n            }\n            this._previousFontIconClass = this.fontIcon;\n        }\n    }\n    /**\n     * Cleans up a value to be used as a fontIcon or fontSet.\n     * Since the value ends up being assigned as a CSS class, we\n     * have to trim the value and omit space-separated values.\n     */\n    _cleanupFontValue(value) {\n        return typeof value === 'string' ? value.trim().split(' ')[0] : value;\n    }\n    /**\n     * Prepends the current path to all elements that have an attribute pointing to a `FuncIRI`\n     * reference. This is required because WebKit browsers require references to be prefixed with\n     * the current path, if the page has a `base` tag.\n     */\n    _prependPathToReferences(path) {\n        const elements = this._elementsWithExternalReferences;\n        if (elements) {\n            elements.forEach((attrs, element) => {\n                attrs.forEach(attr => {\n                    element.setAttribute(attr.name, `url('${path}#${attr.value}')`);\n                });\n            });\n        }\n    }\n    /**\n     * Caches the children of an SVG element that have `url()`\n     * references that we need to prefix with the current path.\n     */\n    _cacheChildrenWithExternalReferences(element) {\n        const elementsWithFuncIri = element.querySelectorAll(funcIriAttributeSelector);\n        const elements = (this._elementsWithExternalReferences =\n            this._elementsWithExternalReferences || new Map());\n        for (let i = 0; i < elementsWithFuncIri.length; i++) {\n            funcIriAttributes.forEach(attr => {\n                const elementWithReference = elementsWithFuncIri[i];\n                const value = elementWithReference.getAttribute(attr);\n                const match = value ? value.match(funcIriPattern) : null;\n                if (match) {\n                    let attributes = elements.get(elementWithReference);\n                    if (!attributes) {\n                        attributes = [];\n                        elements.set(elementWithReference, attributes);\n                    }\n                    attributes.push({ name: attr, value: match[1] });\n                }\n            });\n        }\n    }\n    /** Sets a new SVG icon with a particular name. */\n    _updateSvgIcon(rawName) {\n        this._svgNamespace = null;\n        this._svgName = null;\n        this._currentIconFetch.unsubscribe();\n        if (rawName) {\n            const [namespace, iconName] = this._splitIconName(rawName);\n            if (namespace) {\n                this._svgNamespace = namespace;\n            }\n            if (iconName) {\n                this._svgName = iconName;\n            }\n            this._currentIconFetch = this._iconRegistry\n                .getNamedSvgIcon(iconName, namespace)\n                .pipe(take(1))\n                .subscribe(svg => this._setSvgElement(svg), (err) => {\n                const errorMessage = `Error retrieving icon ${namespace}:${iconName}! ${err.message}`;\n                this._errorHandler.handleError(new Error(errorMessage));\n            });\n        }\n    }\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"19.2.6\", ngImport: i0, type: MatIcon, deps: [], target: i0.ɵɵFactoryTarget.Component });\n    static ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"16.1.0\", version: \"19.2.6\", type: MatIcon, isStandalone: true, selector: \"mat-icon\", inputs: { color: \"color\", inline: [\"inline\", \"inline\", booleanAttribute], svgIcon: \"svgIcon\", fontSet: \"fontSet\", fontIcon: \"fontIcon\" }, host: { attributes: { \"role\": \"img\" }, properties: { \"class\": \"color ? \\\"mat-\\\" + color : \\\"\\\"\", \"attr.data-mat-icon-type\": \"_usingFontIcon() ? \\\"font\\\" : \\\"svg\\\"\", \"attr.data-mat-icon-name\": \"_svgName || fontIcon\", \"attr.data-mat-icon-namespace\": \"_svgNamespace || fontSet\", \"attr.fontIcon\": \"_usingFontIcon() ? fontIcon : null\", \"class.mat-icon-inline\": \"inline\", \"class.mat-icon-no-color\": \"color !== \\\"primary\\\" && color !== \\\"accent\\\" && color !== \\\"warn\\\"\" }, classAttribute: \"mat-icon notranslate\" }, exportAs: [\"matIcon\"], ngImport: i0, template: '<ng-content></ng-content>', isInline: true, styles: [\"mat-icon,mat-icon.mat-primary,mat-icon.mat-accent,mat-icon.mat-warn{color:var(--mat-icon-color, inherit)}.mat-icon{-webkit-user-select:none;user-select:none;background-repeat:no-repeat;display:inline-block;fill:currentColor;height:24px;width:24px;overflow:hidden}.mat-icon.mat-icon-inline{font-size:inherit;height:inherit;line-height:inherit;width:inherit}.mat-icon.mat-ligature-font[fontIcon]::before{content:attr(fontIcon)}[dir=rtl] .mat-icon-rtl-mirror{transform:scale(-1, 1)}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon{display:block}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-icon{margin:auto}\\n\"], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"19.2.6\", ngImport: i0, type: MatIcon, decorators: [{\n            type: Component,\n            args: [{ template: '<ng-content></ng-content>', selector: 'mat-icon', exportAs: 'matIcon', host: {\n                        'role': 'img',\n                        'class': 'mat-icon notranslate',\n                        '[class]': 'color ? \"mat-\" + color : \"\"',\n                        '[attr.data-mat-icon-type]': '_usingFontIcon() ? \"font\" : \"svg\"',\n                        '[attr.data-mat-icon-name]': '_svgName || fontIcon',\n                        '[attr.data-mat-icon-namespace]': '_svgNamespace || fontSet',\n                        '[attr.fontIcon]': '_usingFontIcon() ? fontIcon : null',\n                        '[class.mat-icon-inline]': 'inline',\n                        '[class.mat-icon-no-color]': 'color !== \"primary\" && color !== \"accent\" && color !== \"warn\"',\n                    }, encapsulation: ViewEncapsulation.None, changeDetection: ChangeDetectionStrategy.OnPush, styles: [\"mat-icon,mat-icon.mat-primary,mat-icon.mat-accent,mat-icon.mat-warn{color:var(--mat-icon-color, inherit)}.mat-icon{-webkit-user-select:none;user-select:none;background-repeat:no-repeat;display:inline-block;fill:currentColor;height:24px;width:24px;overflow:hidden}.mat-icon.mat-icon-inline{font-size:inherit;height:inherit;line-height:inherit;width:inherit}.mat-icon.mat-ligature-font[fontIcon]::before{content:attr(fontIcon)}[dir=rtl] .mat-icon-rtl-mirror{transform:scale(-1, 1)}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon{display:block}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-icon{margin:auto}\\n\"] }]\n        }], ctorParameters: () => [], propDecorators: { color: [{\n                type: Input\n            }], inline: [{\n                type: Input,\n                args: [{ transform: booleanAttribute }]\n            }], svgIcon: [{\n                type: Input\n            }], fontSet: [{\n                type: Input\n            }], fontIcon: [{\n                type: Input\n            }] } });\n\nclass MatIconModule {\n    static ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"19.2.6\", ngImport: i0, type: MatIconModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n    static ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"14.0.0\", version: \"19.2.6\", ngImport: i0, type: MatIconModule, imports: [MatCommonModule, MatIcon], exports: [MatIcon, MatCommonModule] });\n    static ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"19.2.6\", ngImport: i0, type: MatIconModule, imports: [MatCommonModule, MatCommonModule] });\n}\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"19.2.6\", ngImport: i0, type: MatIconModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [MatCommonModule, MatIcon],\n                    exports: [MatIcon, MatCommonModule],\n                }]\n        }] });\n\nexport { MAT_ICON_DEFAULT_OPTIONS, MAT_ICON_LOCATION, MAT_ICON_LOCATION_FACTORY, MatIcon, MatIconModule, MatIconRegistry };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}